/******************************************************************************
* Headers
******************************************************************************/
.include "mmu_macros.S"
#include "op_modes.h"
#include "test_codes.h"
#include "config.h"

/******************************************************************************
* Instructions to be loaded in the vector table
******************************************************************************/
.section .vector_table, "ax", %progbits
prv_vector_table:
    ldr pc, =RESET_handler
    ldr pc, =UND_handler
    ldr pc, =SVC_handler
    ldr pc, =PREF_handler
    ldr pc, =ABT_handler
    ldr pc, =0x00
    ldr pc, =IRQ_handler
    ldr pc, =FIQ_handler

/******************************************************************************
* Exception handlers
******************************************************************************/
/// @brief Reset handler. First instruction executed on power up.
.global RESET_handler
.section .init
.type RESET_handler, %function
RESET_handler:
    b _start

/// @brief Undefined instruction handler. Return value (if any) is stored in
///   in und_return, and can be accessed with get_und_return()
.text
.type UND_handler, %function
UND_handler:
    #ifdef ENABLE_TESTING
    push {r0, r1}
    ldr r1, =und_return
    mov r0, #TESTING_UNDEF
    str r0, [r1]
    pop {r0, r1}
    #endif
    movs pc, lr

/// @brief Supervisor call handler. Return value (if any) is stored in
///   in svc_return, and can be accessed with get_svc_return()
.text
.type SVC_handler, %function
SVC_handler:
    push {r0-r3, r12, lr}
    get_svc_id:
        mrs r1, spsr
        tst r1, #T_BIT
        ldreqb r0, [lr, #-4]  // ARM
        ldrneb r0, [lr, #-2]  // Thumb

    bl svc_handler
    teq r0, #0
    ldrne r1, =svc_return
    strne r0, [r1]

    pop {r0-r3, r12, lr}
    movs pc, lr

/// @brief: Intruction prefetch handler. Return value (if any) is stored in
///   in pref_return, and can be accessed with get_pref_return()
.text
.type PREF_handler, %function
PREF_handler:
    push {r0-r3, r12, lr}
    READ_IFSR r0, r2
    READ_IFAR r1
    bl pref_handler
    ldr r1, =pref_return
    str r0, [r1]
    cmp r0, #0
    movgt r0, #SYS_MODE
    blgt change_saved_op_mode
    pop {r0-r3, r12, lr}
    subs pc, lr, #4     // Return to the same instruction that caused the abort

/// @brief Data abort handler. Return value (if any) is stored in
///   in abt_return, and can be accessed with get_abt_return()
.text
.type ABT_handler, %function
ABT_handler:
    push {r0-r3, r12, lr}
    READ_DFSR r0, r2, r3
    READ_DFAR r1
    bl abt_handler
    ldr r1, =abt_return
    str r0, [r1]
    cmp r0, #0
    pop {r0-r3, r12, lr}
    subgts pc, lr, #4   // Return to next instruction to be executed
    subs pc, lr, #8     // Return to the same instruction that caused the abort

/// @brief Interrupt routine handler. It always saves the context of the
///   current task, and loads the context from the next one. The task to be
///   executed is set by the scheduler, and could be the same task as before
///   if the IRQ had been generated by anything else.
.text
.type IRQ_handler, %function
IRQ_handler:
    push {r0-r3, r12, lr}
    bl irq_handler
    ldr r1, =irq_return
    str r0, [r1]
    cmp r0, #0
    pop {r0-r3, r12, lr}
    bgt load_new_context

    save_context:
        // Get address of the current task context
        push {r0-r3, r12, r14}
        bl scheduler_get_last_task_context_addr
        mov r14, r0

        // Store Table1 address from TTBR0
        READ_TTBR0 r0
        str r0, [r14], #4

        // Store spsr of the IRQ mode
        mrs r0, spsr
        str r0, [r14], #4
        pop {r0-r3, r12}

        stmea r14!, {r0-r12}    // Store first 12 registers

        // Get stack pointer and link register from system mode and return to IRQ mode
        mov r0, r14
        cps #SYS_MODE
        str sp, [r0], #4
        str lr, [r0], #4
        cps #IRQ_MODE
        pop {r14}

        str lr, [r0]    // Store IRQ link register as task program counter

    load_new_context:
        // Get address of the current tasks context
        bl scheduler_get_current_task_context_addr
        mov r14, r0

        // Change TTBR0
        ldr r0, [r14], #4
        WRITE_TTBR0 r0

        // Load spsr
        ldr r0, [r14], #4
        msr spsr, r0

        // Change to system mode, and load stack pointer and link register there
        mov r0, r14
        cps #SYS_MODE
        ldr sp, [r0, #52]    // sp is r13, need to access address 4*13 = 52
        ldr r14, [r0, #56]   // Load r14, the lr
        cps #IRQ_MODE

        ldmfd r14!, {r0-r12}    // Load r0-r12
        ldr r14, [r14, #8]      // Load the program counter in the link register

    subs pc, lr, #4

/// @brief Fast interrupt handler.
.text
.type FIQ_handler, %function
FIQ_handler:
    subs pc, lr, #4


/******************************************************************************
* Exception return values
******************************************************************************/
.text
.type get_und_return, %function
.global get_und_return
get_und_return:
    ldr r0, =und_return
    ldr r0, [r0]
    mov pc, lr

.text
.type get_svc_return, %function
.global get_svc_return
get_svc_return:
    ldr r0, =svc_return
    ldr r0, [r0]
    mov pc, lr

.text
.type get_pref_return, %function
.global get_pref_return
get_pref_return:
    ldr r0, =pref_return
    ldr r0, [r0]
    mov pc, lr

.text
.type get_abt_return, %function
.global get_abt_return
get_abt_return:
    ldr r0, =abt_return
    ldr r0, [r0]
    mov pc, lr

.text
.type get_irq_return, %function
.global get_irq_return
get_irq_return:
    ldr r0, =irq_return
    ldr r0, [r0]
    mov pc, lr

.text
.type get_fiq_return, %function
.global get_fiq_return
get_fiq_return:
    ldr r0, =fiq_return
    ldr r0, [r0]
    mov pc, lr

// All exceptions will load a return value here, if relevant.
.data
und_return:     .word 0
svc_return:     .word 0
pref_return:    .word 0
abt_return:     .word 0
irq_return:     .word 0
fiq_return:     .word 0

