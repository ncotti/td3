/******************************************************************************
* Headers
******************************************************************************/
.include "mmu_macros.S"
#include "op_modes.h"
#include "test_codes.h"
#include "config.h"

.extern und_return, pref_return, abt_return, irq_return

/******************************************************************************
* Instructions to be loaded in the vector table
******************************************************************************/
.section .vector_table, "ax", %progbits
prv_vector_table:
    ldr pc, =RESET_handler
    ldr pc, =UND_handler
    ldr pc, =SVC_handler
    ldr pc, =PREF_handler
    ldr pc, =ABT_handler
    ldr pc, =0x00
    ldr pc, =IRQ_handler
    ldr pc, =FIQ_handler

/******************************************************************************
* Exception handlers
******************************************************************************/
/// @brief Reset handler. First instruction executed on power up.
.global RESET_handler
.section .init
.type RESET_handler, %function
RESET_handler:
    b _start

/// @brief Undefined instruction handler. Return value (if any) is stored in
///   in und_return, and can be accessed with get_und_return()
.text
.type UND_handler, %function
UND_handler:
    #ifdef ENABLE_TESTING
    push {r0, r1}
    ldr r1, =und_return
    mov r0, #TESTING_UNDEF
    str r0, [r1]
    pop {r0, r1}
    #endif  // ENABLE_TESTING

    #ifdef ENABLE_NEON
    push {r0-r3, r12}
    push {lr}
    bl neon_undef_handler
    pop {lr}
    sub lr, lr, r0
    pop {r0-r3, r12}
    #endif  // ENABLE_NEON

    movs pc, lr

/// @brief Supervisor call handler. Executes a function from the syscall table.
.text
.type SVC_handler, %function
SVC_handler:
    srsfd sp!, #SYS_MODE    // Store lr and spsr into system mode stack
    cpsid i, #SYS_MODE
    push {r4-r6, r11, r12, lr}   // Push to stack arguments 5 to 7, which are in registers r4-r6
    ldr r12, =syscall_table
    add r12, r12, r7, lsl #2
    ldr r12, [r12]
    cpsie i, #SYS_MODE
    blx r12
    cpsid i, #SYS_MODE
    pop {r4-r6, r11, r12, lr}
    rfe sp!

/// @brief: Intruction prefetch handler. Return value (if any) is stored
///   in pref_return, and can be accessed with get_pref_return()
.text
.type PREF_handler, %function
PREF_handler:
    push {r0-r3, r12, lr}
    READ_IFSR r0, r2
    READ_IFAR r1
    bl pref_handler
    ldr r1, =pref_return
    str r0, [r1]
    #ifdef ENABLE_TESTING
    cmp r0, #0
    movgt r0, #SYS_MODE
    blgt __change_saved_op_mode
    #endif
    pop {r0-r3, r12, lr}
    subs pc, lr, #4     // Return to the same instruction that caused the abort

/// @brief Data abort handler. Return value (if any) is stored in
///   in abt_return, and can be accessed with get_abt_return()
.text
.type ABT_handler, %function
ABT_handler:
    push {r0-r3, r12, lr}
    READ_DFSR r0, r2, r3
    READ_DFAR r1
    bl abt_handler
    ldr r1, =abt_return
    str r0, [r1]
    cmp r0, #0
    pop {r0-r3, r12, lr}
    subgts pc, lr, #4   // Return to next instruction to be executed
    subs pc, lr, #8     // Return to the same instruction that caused the abort

/// @brief Interrupt routine handler. It always saves the context of the
///   current task, and loads the context from the next one. The task to be
///   executed is set by the scheduler, and could be the same task as before
///   if the IRQ had been generated by anything else.
.text
.type IRQ_handler, %function
IRQ_handler:
    push {r0-r3, r12, lr}
    bl irq_handler
    ldr r1, =irq_return
    str r0, [r1]
    cmp r0, #0
    pop {r0-r3, r12, lr}
    bgt load_new_context

    save_context:
        // Get address of the current task context
        push {r0-r3, r12, r14}
        bl __scheduler_get_last_task_context_addr
        mov r14, r0

        // Store Table1 address from TTBR0
        READ_TTBR0 r0
        str r0, [r14], #4
        add r14, r14, #4    // Ignore ASID, doesn't change

        // Store spsr of the IRQ mode
        mrs r0, spsr
        str r0, [r14], #4
        pop {r0-r3, r12}

        stmea r14!, {r0-r12}    // Store first 12 registers

        // Get stack pointer and link register from system mode and return to IRQ mode
        mov r12, r14
        cps #SYS_MODE
        str sp, [r12], #4
        str lr, [r12], #4
        cps #IRQ_MODE
        pop {r14}

        str lr, [r12], #4    // Store IRQ link register as task program counter

        #ifdef ENABLE_NEON
        // Check if NEON is active, and store NEON registers and disable it
        bl neon_is_enabled
        teq r0, #0
        beq load_new_context
        vmrs r0, FPSCR
        str r0, [r12], #4
        vstmia r12!, {Q0-Q7}
        vstmia r12!, {Q8-Q15}
        bl neon_disable
        #endif // ENABLE_NEON

    load_new_context:
        // Get address of the current tasks context
        bl __scheduler_get_current_task_context_addr
        mov r14, r0

        // Change TTBR0
        ldr r0, [r14], #4   // TTBR0
        ldr r1, [r14], #4   // ASID
        WRITE_TTBR0_WITH_ASID r0, r1

        // Load spsr
        ldr r0, [r14], #4
        msr spsr, r0

        // Change to system mode, and load stack pointer and link register there
        mov r0, r14
        cps #SYS_MODE
        ldr sp, [r0, #52]    // sp is r13, need to access address 4*13 = 52
        ldr r14, [r0, #56]   // Load r14, the lr
        cps #IRQ_MODE

        ldmfd r14!, {r0-r12}    // Load r0-r12
        ldr r14, [r14, #8]      // Load the program counter in the link register

    subs pc, lr, #4

/// @brief Fast interrupt handler.
.text
.type FIQ_handler, %function
FIQ_handler:
    subs pc, lr, #4
