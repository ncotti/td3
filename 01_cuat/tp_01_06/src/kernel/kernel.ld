/* This file defines all sections for the kernel */

/******************************************************************************
*   VMAs
******************************************************************************/
/* Kernel sections must be identity mapped, because they are accesed before
*  and after enabling the MMU. */
ld_vector_table_vma         = 0x00000000;
ld_kernel_text_vma          = 0x70025000;
ld_kernel_data_vma          = 0x70022000;
ld_kernel_rodata_vma        = 0x70023000;
ld_kernel_stack_vma         = 0x70020000;
ld_kernel_bss_vma           = 0x70031000;
ld_kernel_public_data_vma   = 0x70024000;
ld_kernel_syscall_vma       = 0x70021000;

/******************************************************************************
*   Memory sections
******************************************************************************/
/* Init section has all the boot code in the ROM (executable). It must be the
 * first section declared in linker script.
 * "not_executable_rom" is used to mark where the code that must be copied into
 * RAM is and paginate it as read only, not executable. */
.init : AT(ld_rom_origin) ALIGN(4K) {
    *vector_table*(.init)  /* Make sure the reset handler is the first instruction run */
    *(.init)
    PROVIDE(ld_not_executable_rom_vma = ALIGN(4K));
} >rom
PROVIDE(ld_init_vma = ADDR(.init));
PROVIDE(ld_init_size = SIZEOF(.init));
PROVIDE(ld_not_executable_rom_size = ld_rom_length - (ld_not_executable_rom_vma - ld_rom_origin));

/* The vector table has its VMA at 0x00. It doesn't need to be aligned to 4K.
 * Must be written exactly after the ".init" section, and must be a separate
 * section because its VMA is different. */
.vector_table ld_vector_table_vma : {
    *(.vector_table)
} AT>rom
PROVIDE(ld_vector_table_lma = LOADADDR(.vector_table));
PROVIDE(ld_vector_table_size = SIZEOF(.vector_table));

.kernel_text ld_kernel_text_vma : ALIGN(4K) {
    *kernel/*(.text)
} >kernel_ram AT>rom
PROVIDE(ld_kernel_text_lma = LOADADDR(.kernel_text));
PROVIDE(ld_kernel_text_size = SIZEOF(.kernel_text));

.kernel_data ld_kernel_data_vma : ALIGN(4K) {
    *kernel/*(.data)
} >kernel_ram AT>rom
PROVIDE(ld_kernel_data_lma = LOADADDR(.kernel_data));
PROVIDE(ld_kernel_data_size = SIZEOF(.kernel_data));

.kernel_rodata ld_kernel_rodata_vma : ALIGN(4K) {
    *kernel/*(.rodata)
} >kernel_ram AT>rom
PROVIDE(ld_kernel_rodata_lma = LOADADDR(.kernel_rodata));
PROVIDE(ld_kernel_rodata_size = SIZEOF(.kernel_rodata));

.kernel_stack ld_kernel_stack_vma (NOLOAD) : ALIGN(4K) {
    *kernel/*(.stack)
} >kernel_ram
PROVIDE(ld_kernel_stack_size = SIZEOF(.kernel_stack));

.kernel_bss ld_kernel_bss_vma : ALIGN(4K) {
    *(.page_table1)
    PROVIDE(ld_page_table2_vma = .);
    *(.page_table2)
    *kernel/*(.bss)
    /* COMMON section is generated by C compiler, instead of .bss.
    (https://sourceware.org/binutils/docs/ld/Input-Section-Common.html) */
    *kernel/*(COMMON)   /**/
} >kernel_ram
PROVIDE(ld_kernel_bss_size = SIZEOF(.kernel_bss));

.public_data ld_kernel_public_data_vma : ALIGN(4K) {
    *kernel/*(.public_data)
} >kernel_ram AT>rom
PROVIDE(ld_kernel_public_data_lma = LOADADDR(.public_data));
PROVIDE(ld_kernel_public_data_size = SIZEOF(.public_data));

.syscall ld_kernel_syscall_vma : ALIGN(4K) {
    *kernel/*(.syscall)
} >kernel_ram AT>rom
PROVIDE(ld_kernel_syscall_lma = LOADADDR(.syscall));
PROVIDE(ld_kernel_syscall_size = SIZEOF(.syscall));
